%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Journal Article
% LaTeX Template
% Version 2.0 (February 7, 2023)
%
% This template originates from:
% https://www.LaTeXTemplates.com
%
% Author:
% Vel (vel@latextemplates.com)
%
% License:
% CC BY-NC-SA 4.0 (https://creativecommons.org/licenses/by-nc-sa/4.0/)
%
% NOTE: The bibliography needs to be compiled using the biber engine.
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%----------------------------------------------------------------------------------------
%	PACKAGES AND OTHER DOCUMENT CONFIGURATIONS
%----------------------------------------------------------------------------------------
\documentclass[
	a4paper, % Paper size, use either a4paper or letterpaper
	10pt, % Default font size, can also use 11pt or 12pt, although this is not recommended
	unnumberedsections, % Comment to enable section numbering
	twoside, % Two side traditional mode where headers and footers change between odd and even pages, comment this option to make them fixed
]{LTJournalArticle}

\usepackage[utf8]{inputenc}
 % BibLaTeX bibliography file

\usepackage{indentfirst} 
\usepackage{graphicx} % 包含图形
\usepackage{subcaption} % 子图
\usepackage{amsmath}
\usepackage{tcolorbox}

\usepackage{tabularx}
\usepackage{booktabs}
\usepackage{adjustbox}

 % A shortened article title to appear in the running head, leave this command empty for no running head
\linespread{2}
\footertext{\textit{Class Article of "Basis of Quantum Information"} (2024- 06-10)} % Text to appear in the footer, leave this command empty for no footer text
\makeatletter
\newcommand{\rmnum}[1]{\romannumeral #1}
\newcommand{\Rmnum}[1]{\expandafter\@slowromancap\romannumeral #1@}
\makeatother
\setcounter{page}{1} % The page number of the first page, set this to a higher number if the article is to be part of an issue or larger work
\newtcolorbox{mathbox}[1][]{%
    colback=white, % 背景颜色
    colframe=blue!75!black, % 边框颜色
    opacityframe=0, % 边框透明度
    sharp corners, % 边框为直角
    boxrule=0.5mm, % 边框宽度
    left=5pt, % 左边距
    right=5pt, % 右边距
    top=5pt, % 顶部边距
    bottom=5pt, % 底部边距
    #1 % 允许自定义参数
}

\renewcommand{\baselinestretch}{1.2} % Adjust the line spacing


%----------------------------------------------------------------------------------------
%	TITLE SECTION
%----------------------------------------------------------------------------------------

\title{MWPM Decoder} % Article title, use manual lines breaks (\\) to beautify the layout

% Authors are listed in a comma-separated list with superscript numbers indicating affiliations
% \thanks{} is used for any text that should be placed in a footnote on the first page, such as the corresponding author's email, journal acceptance dates, a copyright/license notice, keywords, etc
\author{
	Zicheng Yang,Yuheng Ma,Yiming Xiao,Zikang Lv
}

% Affiliations are output in the \date{} command
\date{\footnotesize \textit{CKC College Zhejiang University，Hangzhou 310058} \\ Dated: June 9th, 2024}

% Full-width abstract
\renewcommand{\maketitlehookd}{%
	\begin{abstract}
		\noindent In the field of quantum informatics, the Minimum Weight Perfect Matching (MWPM) decoder stands as a pivotal error-correction technique within surface code frameworks.\
         This paper do a coarse research on the implementation and evaluation of the MWPM surface code decoder through two principal algorithms: the Blossom V algorithm and a localized Dijkstra algorithm. \ 
         We rigorously test their error thresholds and time complexities, and further compare their performance against a contemporary MWPM decoder library, PyMatching 2.0. \
         Furthermore, we extend our study to juxtapose the MWPM decoder's performance with other kinds of surface code decoders, specifically the cellular automaton decoder. \
         Hopefully, this paper will provide an introduction to the MWPM decoder for future students who do the similar project .\
         For more information, please visit our official GitHub repository at \url{https://github.com/Winfred666/SurfaceCode-MWPMDecoder.git}.
	\end{abstract}
}

%----------------------------------------------------------------------------------------

\begin{document}

\maketitle % Output the title section

%----------------------------------------------------------------------------------------
%	ARTICLE CONTENTS
%----------------------------------------------------------------------------------------

\section{\Rmnum{1}. Introduction}
With the popularity of quantum computing spreading in the investors and researchers,quantum error correcting has also been much under scrutiny.Though in the early time, people  have the scepticism that weather quantum computing can keep and manipulate a quantum state error-free for a long time（"Quantum computing: dream or nightmare?"） ,the development of quantum error correction making it more optimistic.

Among so many prospective codes of quantum error correcting,the most promising classes is the surface code,witch is proposed by Alexei Kitaev in 1997.("Fault-tolerant quantum computation by anyons.")the topological concept of the surface code or toric code is to encode the qubit in a 2D lattice of physics qubits system which has some specific boundary condition("Topological quantum memory").In this case ,we can influence and correct a wide range of qubits by applying a given way on the torus.Although challenges of fabricating a large-scale quantum memory still exist ,the progresses on experimental advances in recent years give us hope to make it a reality.("Implementing a strand of a scalable fault-tolerant quantum computing fabric"、"Logic gates at the surface code threshold: Superconducting qubits poised for fault-tolerant quantum computing.")

Another significant period of a quantum error correcting task is to decoder.It is natural that we want to find an optimal solution to figure out the most probably error and correct it for every given measurement,witch is called the Maximums Like Algorithm.But it seems unpractical for its exponential operation time.("On the hardnesses of several quantum decoding problems")So how to balance between performance and running time of the algorithm becomes the priority .A lot of solution have been designed to solve such problems,such as the graph algorithm and neural network("Decoders for Topological Quantum Error Correction").

In this paper,we will take an insight of a kind of graph algorithm,the Blossom Algorithm. As well as we will compare it with other decoder algorithm from multiple dimensions.


%------------------------------------------------

\section{\Rmnum{2}. Background on Quantum Error Correction}

A standard error correction usually consists of four step"Decoders for Topological Quantum Error Correction":
\begin{enumerate}
	\item \textbf{Encode} : encode the quantum state to another state state:
	\begin{center}
	$\vert \psi \rangle= \alpha \vert 0 \rangle +\beta \vert 1 \rangle \rightarrow \vert \psi_{E} \rangle=\alpha \vert 000 \rangle +\beta \vert 111 \rangle$
	\end{center} 
	\item \textbf{Detect} : detect the quantum errors by measurement
	\item \textbf{correct} : correct those errors and decode the qubits to get the corresponding logical state
	\item \textbf{compute} : compute logical operations on the state by redefining a universal gate set on the code.
\end{enumerate}
Here we will focus on the first three steps and outline our work by the following steps:
\begin{enumerate}
	\item \textbf{Introduce errors}
	\item \textbf{Plot syndromes}
	\item \textbf{Match the syndromes}
	\item \textbf{Get the result}
\end{enumerate}

\subsection{A. toric code}

For a better understanding of the toric code,we assume a L$\times$L lattice,where every single qubit lives on the stage,so we have $L^2$ qubits.The stabilizer group of toric code is generated by two types of operator $A_s$ and $B_p$"Neural Network Decoders for Large-Distance 2D Toric Codes":
\begin{center}
$A_s = \bigotimes X_q,B_p = \bigotimes Z_q$
\end{center}
The X and Z are the Pauli matrix the Hamiltonian of the system is the linear combination of the tow operator:
\begin{center}
$H = -A_s-B_p$
\end{center}
We show the stabilizer and the lattice in Figure 1.
\begin{figure} % Single column figure
	\setlength{\abovecaptionskip}{0.cm} %调整标题上方的距离   
	\setlength{\abovecaptionskip}{0.cm} 
	\includegraphics[width=\linewidth]{img/figure 1.png}
	\caption{An illustration of the lattice.The unit marked by the red line or the blue line shows the $A_s$ operator and $B_p$ operator respectively}
	\label{fig:tcanther}
\end{figure}

\subsection{B.Quantum Error}

Generally speaking,the noisy and environment disturbance is inevitable in real quantum system.It is impossible for us to clarify the procedure of the coupling between the system and the environment.But in fact,we can easy the challenge by simplifying all the quantum errors into two types of error:
\begin{center}
Bit-flips error:$\vert \psi \rangle \rightarrow \hat{X} \vert \psi \rangle$
\end{center}
\begin{center}
Phase-slip error:$\vert \psi \rangle \rightarrow \hat{Z} \vert \psi \rangle$
\end{center}
The X error and the Y error are the fundamental mode of quantum error and they can appear at the same time,which we called Y error.In this paper,we assume that each error has the same probability $p/3$ to occur(in the code we implement ,the p is 0.15).
\begin{figure}[htbp] % Single column figure 
	\centering	%使图片居中显示
	\vspace{-0.8cm}   %调整图片与上文的垂直距离  
	\setlength{\abovecaptionskip}{0.cm} %调整标题上方的距离   
	\setlength{\abovecaptionskip}{0.cm} %调整标题下方的距离 	   
	\setlength{\belowdisplayskip}{3pt} 	
    \begin{subfigure}[b]{0.45\linewidth}
        \includegraphics[width=\linewidth]{img/figure 2.png}
        \caption{errors occur}
        \label{fig:subfig1}
    \end{subfigure}
    \hfill
    \begin{subfigure}[b]{0.45\linewidth}
        \includegraphics[width=\linewidth]{img/figure 2.1.png}
        \caption{detect syndromes.}
        \label{fig:subfig2}
    \end{subfigure}
    \vskip\baselineskip
    \begin{subfigure}[b]{0.45\linewidth}
        \includegraphics[width=\linewidth]{img/figure 2.2.png}
        \caption{matching}
        \label{fig:subfig3}
    \end{subfigure}
    \hfill
    \begin{subfigure}[b]{0.45\linewidth}
        \includegraphics[width=\linewidth]{img/figure 2.3.png}
        \caption{decoder}
        \label{fig:subfig4}
    \end{subfigure}
    \caption{the procedure of an error correction.(a)-(d) shows the different stage respectively}
    \label{fig:fourfigs}
\end{figure}
\subsection{Decoder}
As show in Figure 2(a)-(d),when a series of errors happen and we detect this error by the measurement and collect all the syndromes.The task of decoder is to restore the most possible error.The green line ,red line and blue line in Figure 2(a) indicate the X error ,Z error and Y error.It is showed in the figure 2(b) that we detect these error with the measurement we mention above.The next step and the most challenging part is to match the syndromes and decoder them to get result.We definitely hope the result we get is non-trivial,but sometimes the logical error is inevitable due to the limitation of decoder algorithm"Logical error rate scaling of the toric code".In the next section,we will introduce the Blossom Algorithm and test its logical error and compare it with other decoder algorithm.

%------------------------------------------------

\section{\Rmnum{3}. Blossom Algorithm}
	Here,we implement a decoder algorithm called Blossom Algorithm,which is first proposed by Edmonds in 1965.Edmond's idea requires $O(n^2m)$ times,where n is the number of nodes in the graph and m is the number of edges.The Blossom Algorithm has been developed with the time and different improvement has been conducted.It is impossible for us to cover all the creative ideas.Before we discuss the kind of minimum weight matching Blossom Algorithm,we first get an insight of the oldest Blossom Algorithm.
\begin{enumerate}
	%  needless to illustrate how the graph is composed.
    % \item \textbf{Graph Representation}:First,you should represent the problem as a graph $G=(V,E)$,where V is the set of vertices and E is set of edges with associated weights,as show in Figure 3where each yellow ball represents the vertices and the segment represents the edge which has different weight.
	% \begin{figure} % Single column figure
	% \setlength{\abovecaptionskip}{0.cm} %调整标题上方的距离   
	% \setlength{\abovecaptionskip}{0.cm} 
	% \includegraphics[width=\linewidth]{img/blossom algorithm 1.png}
	% \caption{An illustration of the graph.The balls represent the vertices and some are matched with each other and some are free.}
	% \label{fig:tcanther}
	% \end{figure}

	\item \textbf{Augmenting Paths}:And then,an augmenting path is required.Like branches on a tree,an augmenting path is a path that stars and ends at unmatched vertices and alternate between unmatched and matched edges,as show in Figure 3(b).It can improve the size of the current matching by switching the matched and unmatched edges,as show in Figure 3(c).And the process of matching can repeatedly until no free vertices are left,at which point,we know the matching is maximum,as show in figure 3(d). 
	\begin{figure}[htbp] % Single column figure 
    \centering %使图片居中显示
    \vspace{0cm} %调整图片与上文的垂直距离  
    \setlength{\abovecaptionskip}{0.cm} %调整标题上方的距离   
    \setlength{\belowcaptionskip}{0.cm} %调整标题下方的距离  
    \setlength{\belowdisplayskip}{3pt} %调整标题与下文的距离
	\begin{subfigure}[b]{0.45\linewidth}
        \includegraphics[width=\linewidth]{img/blossom algorithm 2.png}
        \caption{}
        \label{fig:subfig1}
    \end{subfigure}
    \hfill
    \begin{subfigure}[b]{0.45\linewidth}
        \includegraphics[width=\linewidth]{img/blossom algorithm 3.png}
        \caption{}
        \label{fig:subfig2}
    \end{subfigure}
    \vskip\baselineskip
    \begin{subfigure}[b]{0.9\linewidth}
        \includegraphics[width=\linewidth]{img/blossom algorithm 6.png}
        \caption{}
        \label{fig:subfig3}
    \end{subfigure}
    \caption{The procedure of an error correction. (a)-(c) show the different stages respectively.}
    \label{fig:threefigs}
\end{figure}
	\item \textbf{Blossoms}:But things don't always go well.When there is a blossom,a cycle containing an odd number of “pseudo nodes”, where a pseudo node is either a vertex or another blossom,the algorithm fails,as show in Figure 3(e) and 3(f).We can see that since the augmenting path is longer than the shortest path,so is not found.
	\item \textbf{Blossom Contraction and Expansion}:In this case,When an odd-length cycle (blossom) is detected, we should contract it into a single vertex, simplifying the problem and after finding a matching, expand the blossoms back to update the matching accordingly.The Figure 5(a)-(d) show the solution when a blossom is detected step by step.
	\begin{figure}[htbp] % Single column figure 
	\centering	%使图片居中显示
	\vspace{-0.8cm}   %调整图片与上文的垂直距离  
	\setlength{\abovecaptionskip}{0.cm} %调整标题上方的距离   
	\setlength{\abovecaptionskip}{0.cm} %调整标题下方的距离 	   
	\setlength{\belowdisplayskip}{3pt} 	
    \begin{subfigure}[b]{0.45\linewidth}
        \includegraphics[width=\linewidth]{img/blossom algorithm 8.1.png}
        \caption{contract the blossom}
        \label{fig:subfig1}
    \end{subfigure}
    \hfill
    \begin{subfigure}[b]{0.45\linewidth}
        \includegraphics[width=\linewidth]{img/blossom algorithm 8,2.png}
        \caption{find augmenting path}
        \label{fig:subfig2}
    \end{subfigure}
    \vskip\baselineskip
    \begin{subfigure}[b]{0.45\linewidth}
        \includegraphics[width=\linewidth]{img/blossom algorithm 8.3.png}
        \caption{improve the matching}
        \label{fig:subfig3}
    \end{subfigure}
    \hfill
    \begin{subfigure}[b]{0.45\linewidth}
        \includegraphics[width=\linewidth]{img/blossom algorithm 8.4.png}
        \caption{lift the path}
        \label{fig:subfig4}
    \end{subfigure}
    \caption{the procedure of an error correction.(a)-(d) shows the different stage respectively}
\end{figure}
	\item \textbf{Iterative Process}:Finally,repeat the search for augmenting paths, contraction, and expansion until no more augmenting paths can be found.The whole process and code is presented in Figure 6.
\begin{figure} % Single column figure
	\setlength{\abovecaptionskip}{0.cm} %调整标题上方的距离   
	\setlength{\abovecaptionskip}{0.cm} 
	\includegraphics[width=\linewidth]{img/blossom algorithm 9.png}
	\caption{the whole process and the code}
\end{figure}
\end{enumerate}	
	The minimum weight perfect matching algorithm is originated from the initial idea,but it has some improvement to handle with the practical problems.
	The implementation of the algorithm is the following:for every vertex $i$,it has a weight $l(i)$ and every edge is a coupling of the vertices $i,j$,it meets the condition:$w(i,j) \leq l(i)+l(j)$.Every perfect minimum weight matching,the sum of the weight edge is:
\begin{center}
\begin{align*}
    \text{val}(M) &= \sum_{(u,v)\in M}w(u,v) \\
    &\leq \sum_{(u,v)\in M}(l(u)+l(v)) \\
    &\leq \sum_{i=1}^{n}l(i)
\end{align*}
\end{center}
Defining $z_u$ as the vertex labeling of $u$,and we also define $e(u,v)$ an equality edge if $(z_u+z_v=weight(e))$,and at this time the edge labeling of edge is called $z_e$.It requires $z_e=z_u+z_v-weight(e)=0$.
The augmenting path composed of "equality edges" is continuously expanded, and since all the edges used for expansion are "equality edges", the final maximum weight perfect matching obtained is still all "equality edges".
In Figure 7,we demonstrate the whole process of this algorithm in detail.It consists of four step:
\begin{enumerate}
	\item \textbf{Grow}:If edge$(u,v)$ is tight,$l(u) = + $and $l(v) = \emptyset$ then the tree to which $u$ belongs can be "grown" by acquiring node $u$ and the corresponding matched node,as shown in the Figure 7(a)
	\item \textbf{Augment}:If edge $(u,v) $is tight,$l(u) = l(v) = + $and $u,v$ belong to different trees then the cardinality of matching $x$ can be increased by "flipping" variable $x_e$ for edges $e$ along the path connecting the roots of the two trees,as shown in Figure 7(b).All nodes in the trees become error-free.
	\item \textbf{Shrink}:If edge $(u,v) $is tight,$l(u) = l(v) = + $and $u,v$ belong to the same tree then there is cycle of odd length that can be shrunk to a blossom,as shown in Figure 7(c).The dual variable for this new blossom is set to 0.
	\item \textbf{Expand}:If node $v$ is a blossom with $y_e = 0$ and$l(v) = -$ then it can be expanded.
\begin{figure} % Single column figure
	\setlength{\abovecaptionskip}{0.cm} %调整标题上方的距离   
	\setlength{\abovecaptionskip}{0.cm} 
	\includegraphics[width=\linewidth]{img/minimum weight.png}
	\caption{An illustration of the minimum weight perfect matching}
\end{figure}
\end{enumerate}
	the $u^-$ represents odd vertex in an alternating tree,the $u^+$ represents the even vertex in an alternating tree and $u^{\emptyset}$ represents an vertex not in any alternating tree.
\section{\Rmnum{4}. Cellular Automation Decoder}



Besides the Blossom Algorithm,we also get an insight of another decoder,the Cellular Automation Decoder.





\section{\Rmnum{5}. Test and result}

There is two critical parameter to evaluate the performance of a decoder:the error threshold and the time complexity.

However, One pitfall about test set of surface code is the usage of noisy model.
Though depolarizing noise model is the best one to simulate the real condition, 
most of the test program just generate only bit-flip errors to test the decoder.
So in \ref{fig:errorate2} we translate osur physical error rate
to the unit of commonly used one.

\begin{figure}[htbp] % Single column figure 
    \centering %使图片居中显示
    \vspace{0cm} %调整图片与上文的垂直距离  
    \setlength{\abovecaptionskip}{0.cm} %调整标题上方的距离   
    \setlength{\belowcaptionskip}{0.cm} %调整标题下方的距离  
    \setlength{\belowdisplayskip}{3pt} %调整标题与下文的距离
	\begin{subfigure}[b]{0.9\linewidth}
        \includegraphics[width=\linewidth]{img/errorThres.png}
        \caption{}
        \label{fig:errorrate1}
    \end{subfigure}
    \hfill
    \begin{subfigure}[b]{0.9\linewidth}
        \includegraphics[width=\linewidth]{img/errorThres2.png}
        \caption{}
        \label{fig:errorate2}
    \end{subfigure}
    \caption{}
    \end{figure}
	In this part,we will show our results and compare different decoders with their error threshold and time complexity .You can see more details in our github website,here,we just give a brief introduction.
	The error threshold is a critical parameter in the design and implementation of fault-tolerant quantum computation.It is related to the threshold theorem,which states that arbitrarily long quantum computations are reliable below a specific error rate that varies with the quantum decoders we use.Above the specific error rate,the reliability of the quantum computation rapidly deteriorates,making it impossible to conduct a fault-tolerant quantum computation.
	Figure 8 (a)-(b) shows the logical error rate varying with the phase-flip and bit-flip error rate under the noise model respectively.For four different scale quantum memories, we set up 25 different groups of error rates,each group of error rates for 500 simulation tests, and calculate the logic error rate.We can calculate the error threshold by recording the intersection of four lines.And it shows the error threshold is about 0.104.As the time complexity ,shown in the Figure 9 (a)-(b) and table 1,the minimum weight perfect matching has the $O(n^3)$ time complexity.And the other,the Union Code represented by the previous group,has the $O(n)$ time complexity.Though,the minimum weight perfect matching is inferior in time complexity to previous work,it has an advantage over it by its higher error threshold.
\begin{table}[h]
    \caption{Time complexity of different decoders\\(N is physical qubit number)}
    \centering
    \begin{adjustbox}{max width=\columnwidth}
    \begin{tabular}{>{\raggedright\arraybackslash}p{0.6\columnwidth} >{\raggedright\arraybackslash}p{0.4\columnwidth}}
        \toprule
        Decoder & Time Complexity \\
        \midrule
        MWPM(original) & $O(n^3logn)$ \\
        MWPM(M-local-dijkstra) & $O(n^2Mlogn)$ \\
        MWPM(sparse blossom) & $O(n)$ \\
        Cellular Automaton & $O(n^2)$ \\
        Union Find & $O(n)$ \\
        \bottomrule
    \end{tabular}
    \end{adjustbox}
\end{table}

%------------------------------------------------
\section{\Rmnum{6}. Conclusion}

%----------------------------------------------------------------------------------------
%	 REFERENCES
%----------------------------------------------------------------------------------------


%-------------------{}---{}------------------------------------------------------------------

\end{document}
